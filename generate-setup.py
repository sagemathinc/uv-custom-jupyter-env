#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
"""
Interactive generator for CoCalc custom Jupyter kernel setup scripts.

Run this script, answer the prompts, and it produces a self-contained bash
script that can be copied to any CoCalc project and executed there.

Usage:
    python3 generate-setup.py
"""

import json
import os
import re
import stat
import sys


def ask(prompt: str, *, default: str = "", validate=None) -> str:
    """Prompt the user for input with an optional default and validator."""
    while True:
        suffix = f" [{default}]" if default else ""
        try:
            value = input(f"{prompt}{suffix}: ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\nAborted.")
            sys.exit(1)
        if not value:
            value = default
        if not value:
            print("  A value is required.")
            continue
        if validate:
            err = validate(value)
            if err:
                print(f"  {err}")
                continue
        return value


def validate_env_name(name: str) -> str | None:
    if not re.fullmatch(r"[a-z][a-z0-9]*(-[a-z0-9]+)*", name):
        return (
            "Must be lowercase letters, digits, and dashes "
            "(e.g. 'my-course-env'). Must start with a letter."
        )
    return None


def validate_python_version(version: str) -> str | None:
    if not re.fullmatch(r"3\.\d{1,2}", version):
        return "Expected format: 3.XX (e.g. 3.11, 3.12)"
    return None


def ask_packages() -> list[str]:
    """Interactively collect package specifications."""
    print()
    print("Enter the packages to install, one per line.")
    print("You can use pip version syntax (e.g. numpy, pandas==3.0, 'numpy>=2.3,<2.4').")
    print("For GitHub repos: git+https://github.com/user/repo.git")
    print("Press Enter on an empty line when done.")
    print()

    packages: list[str] = []
    while True:
        try:
            line = input(f"  package [{len(packages) + 1}]: ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\nAborted.")
            sys.exit(1)
        if not line:
            if not packages:
                print("  Please enter at least one package.")
                continue
            break
        packages.append(line)

    return packages


def generate_script(
    env_name: str,
    display_name: str,
    python_version: str,
    packages: list[str],
) -> str:
    """Generate the bash setup script content."""
    # Build the package list as a nicely formatted bash array
    pkg_lines = []
    for pkg in packages:
        # Quote specs that contain special chars
        if any(c in pkg for c in "<>=!@ "):
            pkg_lines.append(f'    "{pkg}"')
        else:
            pkg_lines.append(f"    {pkg}")

    # Always ensure ipykernel is present
    has_ipykernel = any("ipykernel" in p for p in packages)
    if not has_ipykernel:
        pkg_lines.append("    ipykernel")

    pkg_array = "\n".join(pkg_lines)
    env_dir = f"$HOME/{env_name}"

    return f"""\
#!/usr/bin/env bash
# SPDX-License-Identifier: Apache-2.0
#
# Setup script for Jupyter kernel "{display_name}" on CoCalc.
#
# This script is self-contained and can be copied to any CoCalc project.
# It is safe to re-run: it will update an existing environment in-place.
#
# Usage:  bash {env_name}-setup.sh
#
# Generated by: https://github.com/haraldschilly/uv-custom-jupyter-env

set -euo pipefail

ENV_DIR="{env_dir}"
KERNEL_NAME="{env_name}"
DISPLAY_NAME="{display_name}"
PYTHON_VERSION="{python_version}"

PACKAGES=(
{pkg_array}
)

# --- CoCalc environment housekeeping ----------------------------------------
# CoCalc shells start inside a conda environment.  Deactivate it so uv creates
# a clean venv without inheriting conda paths.
if [[ -f /ext/venvs/cocalc/bin/activate ]]; then
    source /ext/venvs/cocalc/bin/activate
    conda deactivate 2>/dev/null || true
fi

# --- Create or reuse virtual environment ------------------------------------
if [[ -d "$ENV_DIR" ]]; then
    echo "=== Environment '$ENV_DIR' already exists — updating in-place ==="
else
    echo "=== Creating environment at $ENV_DIR (Python $PYTHON_VERSION) ==="
    uv venv --python "$PYTHON_VERSION" "$ENV_DIR"
fi

# --- Install / update packages ----------------------------------------------
echo "=== Installing ${{#PACKAGES[@]}} packages ==="
uv pip install --python "$ENV_DIR/bin/python" "${{PACKAGES[@]}}"

# --- Register Jupyter kernel ------------------------------------------------
echo "=== Registering Jupyter kernel '$KERNEL_NAME' ==="
"$ENV_DIR/bin/python" -m ipykernel install \\
    --user \\
    --name "$KERNEL_NAME" \\
    --display-name "$DISPLAY_NAME (Python $PYTHON_VERSION)"

# --- Add CoCalc metadata to kernel spec ------------------------------------
KERNEL_JSON="$HOME/.local/share/jupyter/kernels/$KERNEL_NAME/kernel.json"
if [[ -f "$KERNEL_JSON" ]]; then
    "$ENV_DIR/bin/python" -c "
import json, pathlib
p = pathlib.Path('$KERNEL_JSON')
k = json.loads(p.read_text())
k['metadata'] = {{
    'cocalc': {{
        'priority': 100,
        'description': 'Custom environment for $DISPLAY_NAME',
        'url': 'https://github.com/haraldschilly/uv-custom-jupyter-env'
    }}
}}
p.write_text(json.dumps(k, indent=1) + '\\n')
"
    echo "=== Added CoCalc metadata to kernel spec ==="
fi

echo
echo "=== Done ==="
echo "Kernel '$DISPLAY_NAME (Python $PYTHON_VERSION)' is ready."
echo "Refresh your Jupyter notebook page to see it in the kernel picker."
echo "To use in a terminal:  source $ENV_DIR/bin/activate"
"""


def generate_notebook(env_name: str, display_name: str, python_version: str) -> dict:
    """Generate a starter Jupyter notebook with the kernel pre-configured."""
    return {
        "nbformat": 4,
        "nbformat_minor": 5,
        "metadata": {
            "kernelspec": {
                "display_name": f"{display_name} (Python {python_version})",
                "language": "python",
                "name": env_name,
            },
            "language_info": {
                "name": "python",
                "version": python_version,
            },
        },
        "cells": [
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    f"# {display_name}\n",
                    "\n",
                    "Verify the environment is working correctly.",
                ],
            },
            {
                "cell_type": "code",
                "metadata": {},
                "source": [
                    "import sys\n",
                    "sys.version",
                ],
                "outputs": [],
                "execution_count": None,
            },
            {
                "cell_type": "code",
                "metadata": {},
                "source": [
                    "!pip list",
                ],
                "outputs": [],
                "execution_count": None,
            },
        ],
    }


def main():
    print("=" * 60)
    print("  CoCalc Custom Jupyter Kernel — Setup Script Generator")
    print("=" * 60)
    print()
    print("This will generate a self-contained bash script that sets up")
    print("a custom Jupyter kernel in any CoCalc project using uv.")
    print()

    env_name = ask(
        "Environment name (lowercase, dashes ok)",
        default="my-course-env",
        validate=validate_env_name,
    )

    display_name = ask(
        "Display name (shown in the Jupyter kernel picker)",
        default=env_name.replace("-", " ").title(),
    )

    python_version = ask(
        "Python version",
        default="3.11",
        validate=validate_python_version,
    )

    packages = ask_packages()

    # --- Generate and write the script ------------------------------------------
    script_content = generate_script(env_name, display_name, python_version, packages)
    output_filename = f"{env_name}-setup.sh"

    print()
    print(f"--- Preview of {output_filename} ---")
    print(script_content)
    print(f"--- End of preview ---")
    print()

    notebook_filename = f"{env_name}-test.ipynb"
    confirm = ask(
        f"Write '{output_filename}' and '{notebook_filename}' to the current directory?",
        default="yes",
    )
    if confirm.lower() not in ("yes", "y"):
        print("Aborted. Nothing was written.")
        sys.exit(0)

    # Write setup script
    output_path = os.path.join(os.getcwd(), output_filename)
    with open(output_path, "w") as f:
        f.write(script_content)

    # Set executable permission
    st = os.stat(output_path)
    os.chmod(output_path, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    # Write starter notebook
    notebook_path = os.path.join(os.getcwd(), notebook_filename)
    notebook = generate_notebook(env_name, display_name, python_version)
    with open(notebook_path, "w") as f:
        json.dump(notebook, f, indent=1)
        f.write("\n")

    print()
    print(f"Wrote: {output_path}")
    print(f"Wrote: {notebook_path}")
    print()
    print("Next steps:")
    print(f"  1. Run the setup:        bash {output_filename}")
    print(f"  2. Open the notebook:    open {notebook_filename}")
    print(f"  3. Or copy both files to another CoCalc project.")
    print(f"  4. To update packages later, edit the PACKAGES array in")
    print(f"     {output_filename} and re-run it.")


if __name__ == "__main__":
    main()
